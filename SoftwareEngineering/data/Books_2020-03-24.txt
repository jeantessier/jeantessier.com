name: Production_Ready_GraphQL
title: [[https://book.productionreadygraphql.com/][Production Ready GraphQL]]
author: Marc-Andr&eacute; Giroux
publisher: self-published
year: 2020
acquired: 2020-03-23
start: 2020-03-24
stop: 2020-05-16

Self-published, so the page setting is a little strange (I suspect LaTeX) and
the text could have used some editing.  Switching between first person (_we_)
and second person (_you_) within the same paragraph forces mental switching on
the part of the reader that are not necessary.  A good editor would have caught
these and made the prose tighter.  But the author built GraphQL APIs at Spotify
and GitHub, so he knows his material.

He advocates for building APIs that are as specific as possible, instead of
generic ones.  Especially when it comes to mutations.  The more specific the
better.

There is a complex description of using cursor-based pagination instead of the
more common ones that use an offset.  They are more resilient to cases where new
data gets added or removed in the list while paging through it.

There is an interesting bit about how to deal with errors.  The author
distinguishes between _client_ errors, essentially protocol errors, and _user_
errors, errors in the business logic.  E.g., email already in use, password too
weak.

The author acknowledges that GraphQL still needs to grow in a few areas.
Companies use it mostly for internal, private APIs.  Best practices around error
messages and observability (tracing, rate limiting, etc.) are still emerging.
When you build a GraphQL client against a published API, you still need to learn
the specific ways that API does everything besides queries and mutations.

When the author presents his preferred workflow, it is front-loaded with a lot
of analysis.  You craft the schema carefully before you  implement it, and
gather a lot of feedback from beta clients before final publication.  This is
very much a waterfall process and it does not work well in practice.  You need
to put things in the hands of users to see how they will use them.  There is
only so much you can really anticipate, or that users can tell you ahead of
time.  We need a technology that can operate in tight feedback cycles and evolve
side-by-side with real world usage.

He provides a code example for schema stitching, which is deprecated, but not
for a federated schema, which is a promising technology.  It would have been
nice to look at both options side-by-side and show how federation handles some
of the limitations of stitching.

At the end of the chapter on versioning, the advice is big-design-up-front, yet
again.  The author is quick to point out the risks of breaking clients, but
there are real risks to a stagnating API too.

The chapter on documentation is great.  Don't just provide a dictionary of types
and fields.  Also provide examples that show how these things work together to
solve a problem.  Maybe even provide high-level examples that solve business
problems using multiple parts of your API.

_More to come._
