I found a way to do data-driven tests in [[http://rspec.info/][RSpec]].  I was
doing a code review for a colleague when I noticed a series of separate tests
for various inputs: a string, an integer, a float, a negative value, etc.  My
colleague could rewrite their tests much more succinctly with a table showing
various inputs and their expected results.

    RSpec.describe _SomeClassUnderTest_ do
        describe '_#some%5Fmethod%5Funder%5Ftest_' do
            subject { described%5Fclass.new._some%5Fmethod%5Funder%5Ftest_ input%5Fvalue }
            &nbsp;
            [
                [ 'a string', '123', '123.00' ],
                [ 'an integer', 123, '123.00' ],
                [ 'a float', 123.0, '123.00' ],
                [ 'a negative number', -123, '-123.00' ],
                [ 'nil', nil, 'nil' ],
            ].each do |variation, input, expected%5Foutput|
                describe 'when the input is #{variation}' do
                    let(:input%5Fvalue) { input }
                    it { is%5Fexpected.to eq(expected%5Foutput) }
                end
            end
            &nbsp;
            describe 'when the input is invalid' do
                let(:input%5Fvalue) { 'invalid' }
                it { expect { subject }.to raise%5Ferror }
            end
        end
    end

I have to remind myself that the Ruby interpreter is running while Ruby is
parsing its own program.  This gives a lot of opportunities for the program to
generate itself.  Sounds dangerous, but it is also _very_ powerful.

I drew inspiration from
[[https://stackoverflow.com/questions/8754582/best-way-to-organize-tests-in-rspec-that-have-a-combinations-of-factor][an old Stack Overflow article]].
It also has another example that uses =shared_examples=.
