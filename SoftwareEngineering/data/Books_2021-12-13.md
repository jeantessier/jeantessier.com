name: Domain_Driven_Rails
title: [Domain-Driven Rails](http://leanpub.com/rails-meets-ddd/)
author: Robert Pankowecki
publisher: Leanpub
year: 2020
acquired: 2021-12-13
start: 2021-12-13
stop: 2021-12-31

We're reading this book as part of a book club at work.  I read an early copy
that still needed a lot of editing to fix typos and grammar.  I'll admit that I
found it _very_ distracting.

The beginning covers concepts of Domain-Driven Design like bounded contexts,
value objects, and aggregates.  I like how the author uses services to implement
behavior that does not squarely belong to any single aggregate.  It all sets the
stage for the latter part where the author shows how to use events to normalize
communication between aggregates.  It is also a good way to enforce partitions
between parts of the code.

The examples are all set in the context of Rails and rely heavily on the
`rails_event_store` gem and the patterns it promotes.  These are useful, but
they are also difficult to replicate with other messaging systems like RabbitMQ
or Kafka.  For example, with `rails_event_store`, you can put a message on
multiple streams very cheaply, so you can have per-object streams (e.g.,
`user-1234` or `user$1234`) sitting next to general streams (e.g., `users`).
This allows you to rehydrate `User` with ID `1234` by replaying that stream
whenever needed.  RabbitMQ won't let you replay streams and Kafka streams are
more costly to replay from the beginning, so you tend to maintain state in
memory for the lifetime of the process.

When the author started discussing process managers, they looked to me a lot
like the saga pattern with an orchestrator.  The author does point to how both
_process manager_ and _saga_ have subtly different definitions between the CQRS
and Microsoft communities.  Apparently, _process manager_ comes from
[_Enterprise Integration Patterns_](BooksBackLog.html#Enterprise_Integration_Patterns).

The author covers many of the problems I've seen before with timing events and
messages with database transactions, dealing with failures and rollbacks, and
trying to guarantee once-and-only-once semantics.  The author describes a nice
setup where an internal event system (e.g., `rails_event_store`) tied to
database transactions, which feeds a separate process that puts them on the
external message bus (e.g., Kafka).  If a transaction rolls back, the events are
removed from the internal bus and it's as if nothing happened.  Once an event is
persisted, it gets published to the rest of the system.

I also really appreciated how the author used Ruby's `#permutation` and
`#repeated_permutation` methods to programmatically test variations of a
sequence of messages where the order didn't matter.

The author references Stephan Hagemann's
[_Component-Based Rails Applications_](#Component_Based_Rails_Applications) in a
few places.
